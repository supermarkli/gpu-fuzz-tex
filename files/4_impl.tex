\section{Implementation}
\label{sec:impl}
This section details the implementation of the system design described in Section~\ref{sec:design}. Our system is developed in Python and comprises approximately 2,000 lines of code.

We implemented a library where each operator is represented as a distinct class to realize the operator modeling and constraint-based testcase generation concepts described in Section~\ref{sec:design}. This modeling approach was applied to 11 operator families (Table~\ref{tab:operator_families}), chosen for their prevalence in deep learning models and their complex, error-prone memory access patterns.

An execution controller translates the generated parameter configurations into executable test cases for PyTorch~\cite{paszke2019pytorch}, TensorFlow~\cite{abadi2016tensorflow}, and PaddlePaddle~\cite{ma2019paddlepaddle}. The execution is wrapped with NVIDIA's compute-sanitizer~\cite{nvidia2023compsan}. When it detects an error, the controller archives the logs and the triggering operator configuration to ensure reproducibility.

\begin{table}[t]
\centering
\caption{Supported Operator Families in \textsc{GPU-Fuzz}}
\label{tab:operator_families}
\footnotesize
\begin{tabularx}{0.5\textwidth}{lX}
\toprule
\textbf{Operator Family} & \textbf{Specific Operators} \\
\midrule
Convolution & \makecell[l]{Conv (1d, 2d, 3d), ConvTranspose (1d, 2d, 3d)} \\
\midrule
Pooling & \makecell[l]{MaxPool (1d, 2d, 3d), AvgPool (1d, 2d, 3d), \\ FractionalMaxPool (2d, 3d), LPPool, \\ AdaptiveAvgPool (1d, 2d, 3d), AdaptiveMaxPool (1d, 2d, 3d)} \\
\midrule
Padding & \makecell[l]{ConstantPad, ReflectionPad, ReplicationPad,\\ ZeroPad,  CircularPad} \\
\midrule
Element-Wise Unary & abs, sin, sqrt, ... \\
\midrule
Element-Wise Binary & add, sub, mul, ... \\
\midrule
Matrix Ops & MatMul, BMM \\
\bottomrule
\end{tabularx}
\end{table}

\section{Preliminary and Motivation}
\label{sec:bg}

This section provides the necessary technical background and motivation for our research.

\subsection{GPU Kernel Error Types}

GPU kernels, typically written in CUDA, are susceptible to various errors that can compromise DL frameworks. Our fuzzer targets critical bugs such as illegal memory accesses (where a thread reads/writes out-of-bounds), race conditions from unsynchronized parallel memory access, misaligned memory accesses that trigger hardware exceptions, and integer overflows that can lead to subsequent memory corruption.

\subsection{Debugging and Instrumentation Tools}

To detect these errors, our work relies on NVIDIA's specialized tools. The NVIDIA \texttt{compute-sanitizer} is a powerful tool for detecting memory access errors and race conditions in GPU applications. It functions by instrumenting the GPU code to check memory operations at runtime. When a violation is detected, it terminates the application and generates a detailed report. In GPU-Fuzz, \texttt{compute-sanitizer} serves as our primary test oracle for detecting memory corruption.

\subsection{Motivation}

Our research is driven by two core observations: the inefficiency of existing fuzzers and the irreproducibility of GPU bugs.

\parh{The Inefficiency of Existing Fuzzers.} A fundamental "semantic gap" challenges the fuzzing of DL frameworks. APIs expect highly structured inputs with strict constraints on data types and tensor shapes.

\parh{The Irreproducibility of GPU Bugs.} Even when a GPU crash is triggered, reproducing it manually is often a time-consuming and arduous process. A typical bug report might only contain a stack trace, but the crash itself is often highly dependent on the specific inputs, tensor shapes, and operator parameters that triggered the illegal state. Without a systematic way to record the exact inputs and parameters, debugging and fixing these issues becomes a significant engineering burden.

These observations motivate the design of GPU-Fuzz. We need a system that can bridge the semantic gap by generating valid, boundary-aware inputs to effectively test GPU kernels. Furthermore, we need a fully automated system that not only finds crashes but also provides the necessary fuzzing information through logs to assist in reproducing the discovered bugs, drastically improving the efficiency of the debugging workflow.

@misc{rock5itx,
  author = {Radxa},
  title = {Radxa ROCK 5 ITX},
  year = {2024},
  url = {https://radxa.com/products/rock5/5itx/},
}

@misc{pixel8,
  author = {Google},
  title = {Pixel 8},
  year = {2024},
  url = {https://store.google.com/us/product/pixel_8?hl=en-US},
}

@misc{armv7m,
  author = {Arm},
  title = {Armv7-M Architecture},
  year = {2024},
  url = {https://developer.arm.com/documentation/ddi0403/latest/},
}

@misc{armv7mpu,
  author = {Arm},
  title = {Armv7-M Memory Protection Unit},
  year = {2024},
  url = {
         https://developer.arm.com/documentation/101407/latest/Debugging/Debug-Windows-and-Dialogs/Core-Peripherals/Armv7-M-cores/Armv7-M--Memory-Protection-Unit
         },
}

@misc{armcortexm,
  author = {Arm},
  title = {M-Profile Architectures},
  year = {2024},
  url = {https://www.arm.com/architecture/cpu/m-profile},
}

@misc{armcca,
  author = {Arm},
  title = {Arm Confidential Compute Architecture},
  year = {2024},
  url = {
         https://www.arm.com/architecture/security-features/arm-confidential-compute-architecture
         },
}

@misc{aesstand,
  author = {NIST},
  title = {Advanced Encryption Standard (AES)},
  year = {2001},
  url = {https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.197.pdf},
}

@misc{molesite,
  title = {MOLE Website},
  url = {https://sites.google.com/view/mole-gpu},
  year = {2025},
}

@inproceedings{deng2022strongbox,
  title = {Strongbox: A gpu tee on arm endpoints},
  author = {Deng, Yunjie and Wang, Chenxu and Yu, Shunchang and Liu, Shiqing and
            Ning, Zhenyu and Leach, Kevin and Li, Jin and Yan, Shoumeng and He,
            Zhengyu and Cao, Jiannong and others},
  booktitle = {Proceedings of the 2022 ACM SIGSAC Conference on Computer and
               Communications Security},
  pages = {769--783},
  year = {2022},
}

@inproceedings{wang2024cage,
  title = {CAGE: Complementing Arm CCA with GPU Extensions},
  author = {Wang, Chenxu and Zhang, Fengwei and Deng, Yunjie and Leach, Kevin
            and Cao, Jiannong and Ning, Zhenyu and Yan, Shoumeng and He, Zhengyu},
  booktitle = {Network and Distributed System Security (NDSS) Symposium},
  year = {2024},
}

@inproceedings{han2023mytee,
  title = {MyTEE: Own the Trusted Execution Environment on Embedded Devices.},
  author = {Han, Seung-Kyun and Jang, Jinsoo},
  booktitle = {NDSS},
  year = {2023},
}

@misc{cortexmirq,
  author = {Arm},
  title = {Exception types},
  year = {2024},
  url = {
         https://developer.arm.com/documentation/dui0497/a/the-cortex-m0-processor/exception-model/exception-types
         },
}

@misc{armtrustzone,
  author = {Arm},
  title = {TrustZone for Cortex-A},
  year = {2024},
  url = {https://www.arm.com/technologies/trustzone-for-cortex-a},
}

@misc{arms2trans,
  author = {Arm},
  title = {Stage 2 translation},
  year = {2024},
  url = {https://developer.arm.com/documentation/102142/0100/Stage-2-translation
         },
}

@misc{huawei,
  author = {Huawei},
  title = {Huawei Website},
  url = {https://consumer.huawei.com/en/},
  year = {2024},
}

@misc{vivo,
  author = {Vivo},
  title = {Vivo Website},
  url = {https://www.vivo.com/en},
  year = {2024},
}

@misc{xiaomi,
  author = {Xiaomi},
  title = {Xiaomi Website},
  url = {https://www.mi.com/global/},
  year = {2024},
}


@misc{malicsf,
  author = {Boris Brezillon},
  title = {PanCSF: A new DRM driver for Mali CSF-based GPUs},
  year = {2024},
  url = {
         https://www.collabora.com/news-and-blog/news-and-events/pancsf-a-new-drm-driver-for-mali-csf-based-gpus.html
         },
}

@misc{rodinia,
  author = {Github},
  title = {gpu-rodinia},
  year = {2024},
  url = {https://github.com/yuhc/gpu-rodinia},
}

@article{lecun1998gradient,
  title = {Gradient-based learning applied to document recognition},
  author = {LeCun, Yann and Bottou, L{\'e}on and Bengio, Yoshua and Haffner,
            Patrick},
  journal = {Proceedings of the IEEE},
  volume = {86},
  number = {11},
  pages = {2278--2324},
  year = {1998},
  publisher = {Ieee},
}

@article{iandola2016squeezenet,
  title = {SqueezeNet: AlexNet-level accuracy with 50x fewer parameters and< 0.5
           MB model size},
  author = {Iandola, Forrest N},
  journal = {arXiv preprint arXiv:1602.07360},
  year = {2016},
}

@article{howard2017mobilenets,
  title = {Mobilenets: Efficient convolutional neural networks for mobile vision
           applications},
  author = {Howard, Andrew G},
  journal = {arXiv preprint arXiv:1704.04861},
  year = {2017},
}

@misc{yolov4,
  author = {Github},
  title = {darknet},
  year = {2024},
  url = {https://github.com/AlexeyAB/darknet},
}

@inproceedings{heteezhu2020enabling,
  title = {Enabling rack-scale confidential computing using heterogeneous
           trusted execution environment},
  author = {Zhu, Jianping and Hou, Rui and Wang, XiaoFeng and Wang, Wenhao and
            Cao, Jiangfeng and Zhao, Boyan and Wang, Zhongpu and Zhang, Yuhui and
            Ying, Jiameng and Zhang, Lixin and others},
  booktitle = {2020 IEEE Symposium on Security and Privacy (SP)},
  pages = {1450--1465},
  year = {2020},
  organization = {IEEE},
}

@inproceedings{volos2018graviton,
  title = {Graviton: Trusted execution environments on $\{$GPUs$\}$},
  author = {Volos, Stavros and Vaswani, Kapil and Bruno, Rodrigo},
  booktitle = {13th USENIX Symposium on Operating Systems Design and
               Implementation (OSDI 18)},
  pages = {681--696},
  year = {2018},
}

@inproceedings{jang2019heterogeneous,
  title = {Heterogeneous isolated execution for commodity gpus},
  author = {Jang, Insu and Tang, Adrian and Kim, Taehoon and Sethumadhavan,
            Simha and Huh, Jaehyuk},
  booktitle = {Proceedings of the Twenty-Fourth International Conference on
               Architectural Support for Programming Languages and Operating
               Systems},
  pages = {455--468},
  year = {2019},
}

@inproceedings{erb2017dynamic,
  title = {Dynamic buffer overflow detection for GPGPUs},
  author = {Erb, Christopher and Collins, Mike and Greathouse, Joseph L},
  booktitle = {2017 IEEE/ACM International Symposium on Code Generation and
               Optimization (CGO)},
  pages = {61--73},
  year = {2017},
  organization = {IEEE},
}

@inproceedings{di2018gmod,
  title = {GMOD: A dynamic GPU memory overflow detector},
  author = {Di, Bang and Sun, Jianhua and Li, Dong and Chen, Hao and Quan, Zhe},
  booktitle = {Proceedings of the 27th International Conference on Parallel
               Architectures and Compilation Techniques},
  pages = {1--13},
  year = {2018},
}

@inproceedings{clarm,
  author = {Erb, Christopher and Greathouse, Joseph L.},
  title = {clARMOR: A Dynamic Buffer Overflow Detector for OpenCL Kernels},
  year = {2018},
  isbn = {9781450364393},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3204919.3204934},
  doi = {10.1145/3204919.3204934},
  abstract = {Buffer overflows are a common source of program crashes, data
              corruption, and security exploits. While many tools exist to find
              these issues in CPU programs, buffer overflows are also problematic
              in heterogeneous systems serviced by languages such as OpenCL™.
              Existing buffer overflow detectors for heterogeneous systems are
              either limited to particular vendors or require heavyweight
              instrumentation that results in large runtime overheads.This work
              describes clARMOR, an open source buffer overflow detector for
              OpenCL kernels and APIs. clARMOR is vendor and device neutral; we
              demonstrate its operation on multiple device types from a variety
              of vendors. Rather than requiring heavyweight kernel
              instrumentation, clARMOR uses canary regions to quickly tell if
              data is written outside of any global memory buffer. Rather than
              analyzing every memory access, clARMOR instead verifies that the
              canary regions have not been modified after each user kernel
              finishes. In some cases, clARMOR uses the target device to check
              these canary regions, further reducing the overheads. We show
              experiments demonstrating that, across 143 open source OpenCL
              benchmarks, clARMOR causes an average slowdown of 9.6\% while still
              finding multiple real kernel buffer overflows.},
  booktitle = {Proceedings of the International Workshop on OpenCL},
  articleno = {15},
  numpages = {2},
  keywords = {OpenCL, Open Source Software, GPGPU, Buffer Overflow Detection},
  location = {Oxford, United Kingdom},
  series = {IWOCL '18},
}

@misc{nvh100,
  author = {NVIDIA},
  title = {Confidential Computing on NVIDIA H100 GPUs for Secure and Trustworthy
           AI},
  year = {2023},
  url = {
         https://developer.nvidia.com/blog/confidential-computing-on-h100-gpus-for-secure-and-trustworthy-ai/
         },
}


@misc{nvvgpu,
  author = {NVIDIA},
  title = {NVIDIA Virtual GPU (vGPU) Software},
  year = {2024},
  url = {https://docs.nvidia.com/vgpu/index.html},
}

@misc{amdvgpu,
  author = {AMD},
  title = {AMD MULTIUSER GPU},
  year = {2024},
  url = {
         https://subscriptions.amd.com/newsletters/prographics/images/oct2015/157367_amd_multiuser_gpu_datasheet_a4_fnl.pdf
         },
}

@inproceedings{jiang2022cronus,
  title = {CRONUS: Fault-isolated, secure and high-performance heterogeneous
           computing for trusted execution environment},
  author = {Jiang, Jianyu and Qi, Ji and Shen, Tianxiang and Chen, Xusheng and
            Zhao, Shixiong and Wang, Sen and Chen, Li and Zhang, Gong and Luo,
            Xiapu and Cui, Heming},
  booktitle = {2022 55th IEEE/ACM International Symposium on Microarchitecture
               (MICRO)},
  pages = {124--143},
  year = {2022},
  organization = {IEEE},
}

@inproceedings{park2023safe,
  title = {Safe and Practical GPU Computation in TrustZone},
  author = {Park, Heejin and Lin, Felix Xiaozhu},
  booktitle = {Proceedings of the Eighteenth European Conference on Computer
               Systems},
  pages = {505--520},
  year = {2023},
}

@inproceedings{sridhara2024acai,
  title = {$\{$ACAI$\}$: Protecting Accelerator Execution with Arm Confidential
           Computing Architecture},
  author = {Sridhara, Supraja and Bertschi, Andrin and Schl{\"u}ter, Benedict
            and Kuhne, Mark and Aliberti, Fabio and Shinde, Shweta},
  booktitle = {33rd USENIX Security Symposium (USENIX Security 24)},
  pages = {3423--3440},
  year = {2024},
}

@misc{nvtdx,
  author = {NVIDIA},
  title = {Condential Computing Deployment Guide - (Intel TDX \& KVM)},
  year = {2024},
  url = {https://docs.nvidia.com/cc-deployment-guide-tdx.pdf},
}

@inproceedings{zhenkai2023tunnels,
  author = {Zhang, Zhenkai and Allen, Tyler and Yao, Fan and Gao, Xing and Ge,
            Rong},
  title = {TunneLs for Bootlegging: Fully Reverse-Engineering GPU TLBs for
           Challenging Isolation Guarantees of NVIDIA MIG},
  year = {2023},
  isbn = {9798400700507},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3576915.3616672},
  doi = {10.1145/3576915.3616672},
  abstract = {Recent studies have revealed much detailed information about the
              translation lookaside buffers (TLBs) of modern CPUs, but we find
              that many properties of such components in modern GPUs still remain
              unknown or unclear. To fill this knowledge gap, we develop a new
              GPU TLB reverse-engineering method and apply it to a variety of
              consumer- and server-grade GPUs in Turing and Ampere generations.
              Aside from learning significantly more comprehensive and accurate
              GPU TLB properties, we discover a design flaw of NVIDIA
              Multi-Instance GPU (MIG) feature. MIG claims full partitioning of
              the entire GPU memory system for secure GPU sharing in cloud
              computing. However, we surprisingly find that MIG does not
              partition the last-level TLB, which is shared by all the compute
              units in a GPU. Exploiting this design flaw and learned TLB
              properties, we are able to construct a covert channel for data
              exfiltration across MIG-enforced isolation. To the best of our
              knowledge, this is the first attack on MIG. We evaluate the
              proposed attack on a commercial cloud platform, and we successfully
              achieve reliable data exfiltration from a victim tenant at a speed
              of up to 31 kbps with a very high accuracy around 99.8\%. Even when
              the victim is using the GPU for deep neural network training, the
              transmission can still reach more than 25 kbps with a more than
              99.5\% accuracy. We propose and implement a mitigation approach
              that can effectively thwart data exfiltration through this covert
              channel. Additionally, we present a preliminary study on exploiting
              the access patterns of the last-level TLB to infer the identity of
              applications running in other MIG-created GPU instances.},
  booktitle = {Proceedings of the 2023 ACM SIGSAC Conference on Computer and
               Communications Security},
  pages = {960-974},
  numpages = {15},
  keywords = {gpu tlb, information leakage, nvidia mig},
  location = {Copenhagen, Denmark},
  series = {CCS '23},
}


@inproceedings{2014left,
  author = {Lee, Sangho and Kim, Youngsok and Kim, Jangwoo and Kim, Jong},
  booktitle = {2014 IEEE Symposium on Security and Privacy},
  title = {Stealing Webpages Rendered on Your Browser by Exploiting GPU
           Vulnerabilities},
  year = {2014},
  volume = {},
  number = {},
  pages = {19-33},
  keywords = {Graphics processing units;Security;Kernel;Context;Browsers;Memory
              management;Chromium},
  doi = {10.1109/SP.2014.9},
}

@misc{learned2024leftoverlocals,
  title = {LeftoverLocals: Listening to LLM Responses Through Leaked GPU Local
           Memory},
  author = {Tyler Sorensen and Heidy Khlaaf},
  year = {2024},
  eprint = {2401.16603},
  archivePrefix = {arXiv},
  primaryClass = {cs.CR},
  url = {https://arxiv.org/abs/2401.16603},
}

@inproceedings{zhenkai2024gpu1,
  author = {Yanan Guo and Zhenkai Zhang and Jun Yang},
  title = {{GPU} Memory Exploitation for Fun and Profit},
  booktitle = {33rd USENIX Security Symposium (USENIX Security 24)},
  year = {2024},
  isbn = {978-1-939133-44-1},
  address = {Philadelphia, PA},
  pages = {4033--4050},
  url = {
         https://www.usenix.org/conference/usenixsecurity24/presentation/guo-yanan
         },
  publisher = {USENIX Association},
  month = aug,
}

@misc{miele2015buffer,
  title = {Buffer overflow vulnerabilities in CUDA: a preliminary analysis},
  author = {Andrea Miele},
  year = {2015},
  eprint = {1506.08546},
  archivePrefix = {arXiv},
  primaryClass = {cs.CR},
  url = {https://arxiv.org/abs/1506.08546},
}

@article{tarek2023cucatch,
  title = {Cucatch: A debugging tool for efficiently catching memory safety
           violations in cuda applications},
  author = {Tarek Ibn Ziad, Mohamed and Damani, Sana and Jaleel, Aamer and
            Keckler, Stephen W and Stephenson, Mark},
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {7},
  number = {PLDI},
  pages = {124--147},
  year = {2023},
  publisher = {ACM New York, NY, USA},
}



@article{park2021mind,
  title = {Mind control attack: Undermining deep learning with GPU memory
           exploitation},
  journal = {Computers \& Security},
  volume = {102},
  pages = {102115},
  year = {2021},
  issn = {0167-4048},
  doi = {https://doi.org/10.1016/j.cose.2020.102115},
  url = {https://www.sciencedirect.com/science/article/pii/S0167404820303886},
  author = {Sang-Ok Park and Ohmin Kwon and Yonggon Kim and Sang Kil Cha and
            Hyunsoo Yoon},
  keywords = {Graphics process unit security, GPU memory exploit, Deep learning
              security, Reverse engineering, Compute unified device architecture},
  abstract = {Modern deep learning frameworks rely heavily on GPUs to accelerate
              the computation. However, the security implication of GPU device
              memory exploitation on deep learning frameworks has been largely
              neglected. In this paper, we argue that GPU device memory
              manipulation is a novel attack vector against deep learning
              systems. We present a novel attack method leveraging the attack
              vector, which makes deep learning predictions no longer different
              from random guessing by degrading the accuracy of the predictions.
              To the best of our knowledge, we are the first to show a practical
              attack that directly exploits deep learning frameworks through GPU
              memory manipulation. We confirmed that our attack works on three
              popular deep learning frameworks, TensorFlow, CNTK, and Caffe,
              running on CUDA. Finally, we propose potential defense mechanisms
              against our attack, and discuss concerns of GPU memory safety.},
}


@inproceedings{di2016study,
  author = {Di, Bang and Sun, Jianhua and Chen, Hao},
  title = {A Study of Overflow Vulnerabilities on GPUs},
  year = {2016},
  isbn = {978-3-319-47098-6},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  url = {https://doi.org/10.1007/978-3-319-47099-3_9},
  doi = {10.1007/978-3-319-47099-3_9},
  abstract = {GPU-accelerated computing gains rapidly-growing popularity in many
              areas such as scientific computing, database systems, and cloud
              environments. However, there are less investigations on the
              security implications of concurrently running GPU applications. In
              this paper, we explore security vulnerabilities of CUDA from
              multiple dimensions. In particular, we first present a study on GPU
              stack, and reveal that stack overflow of CUDA can affect the
              execution of other threads by manipulating different memory spaces.
              Then, we show that the heap of CUDA is organized in a way that
              allows threads from the same warp or different blocks or even
              kernels to overwrite each other’s content, which indicates a high
              risk of corrupting data or steering the execution flow by
              overwriting function pointers. Furthermore, we verify that integer
              overflow and function pointer overflow in struct also can be
              exploited on GPUs. But other attacks against format string and
              exception handler seems not feasible due to the design choices of
              CUDA runtime and programming language features. Finally, we propose
              potential solutions of preventing the presented vulnerabilities for
              CUDA.},
  booktitle = {Network and Parallel Computing: 13th IFIP WG 10.3 International
               Conference, NPC 2016, Xi'an, China, October 28-29, 2016,
               Proceedings},
  pages = {103–115},
  numpages = {13},
  keywords = {Buffer overflow, Security, CUDA, GPGPU},
  location = {Xi'an, China},
}

@inproceedings{lee2025lmi,
  title = {Let-Me-In:(Still) Employing In-pointer Bounds Metadata for
           Fine-grained GPU Memory Safety},
  author = {Lee, Jaewon and Chung, Euijun and Singh, Saurabh and Na, Seonjin and
            Kim, Yonghae and Lee, Jaekyu and Kim, Hyesoon},
  booktitle = {2025 IEEE International Symposium on High Performance Computer
               Architecture (HPCA)},
  pages = {1648--1661},
  year = {2025},
  organization = {IEEE},
}

@inproceedings{lee2022shield,
  author = {Lee, Jaewon and Kim, Yonghae and Cao, Jiashen and Kim, Euna and Lee,
            Jaekyu and Kim, Hyesoon},
  title = {Securing GPU via region-based bounds checking},
  year = {2022},
  isbn = {9781450386104},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3470496.3527420},
  doi = {10.1145/3470496.3527420},
  abstract = {Graphics processing units (GPUs) have become essential
              general-purpose computing platforms to accelerate a wide range of
              workloads, such as deep learning, scientific, and high-performance
              computing (HPC) applications. However, recent memory corruption
              attacks, such as buffer overflow, exposed security vulnerabilities
              in GPUs. We demonstrate that out-of-bounds writes are reproducible
              on an Nvidia GPU, which can enable other security attacks.We
              propose GPUShield, a hardware-software cooperative region-based
              bounds-checking mechanism, to improve GPU memory safety for global,
              local, and heap memory buffers. To achieve effective protection, we
              update the GPU driver to assign a random but unique ID to each
              buffer and local variable and store individual bounds information
              in the bounds table allocated in the global memory. The proposed
              hardware performs efficient bounds checking by indexing the bounds
              table with unique IDs. We further reduce the bounds-checking
              overhead by utilizing compile-time bounds analysis,
              workgroup/warp-level bounds checking, and GPU-specific address
              mode. Our performance evaluations show that GPUShield incurs little
              performance degradation across 88 CUDA benchmarks on the Nvidia GPU
              architecture and 17 OpenCL benchmarks on the Intel GPU architecture
              with a marginal hardware overhead.},
  booktitle = {Proceedings of the 49th Annual International Symposium on
               Computer Architecture},
  pages = {27–41},
  numpages = {15},
  keywords = {GPU, memory safety},
  location = {New York, New York},
  series = {ISCA '22},
}

@misc{nvsev,
  author = {NVIDIA},
  title = {{Condential Computing Deployment Guide - (AMD SEV-SNP \& KVM)}},
  year = {2024},
  url = {https://docs.nvidia.com/cc-deployment-guide-snp.pdf},
}

@article{jiang1,
  author = {Jiang, Zhen Hang and Fei, Yunsi and Kaeli, David},
  title = {Exploiting Bank Conflict-based Side-channel Timing Leakage of GPUs},
  year = {2019},
  issue_date = {December 2019},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {16},
  number = {4},
  issn = {1544-3566},
  url = {https://doi.org/10.1145/3361870},
  doi = {10.1145/3361870},
  abstract = {To prevent information leakage during program execution, modern
              software cryptographic implementations target constant-time
              function, where the number of instructions executed remains the
              same when program inputs change. However, the underlying
              microarchitecture behaves differently when processing different
              data inputs, impacting the execution time of the same instructions.
              These differences in execution time can covertly leak confidential
              information through a timing channel.Given the recent reports of
              covert channels present on commercial microprocessors, a number of
              microarchitectural features on CPUs have been re-examined from a
              timing leakage perspective. Unfortunately, a similar
              microarchitectural evaluation of the potential attack surfaces on
              GPUs has not been adequately performed. Several prior work has
              considered a timing channel based on the behavior of a GPU’s
              coalescing unit. In this article, we identify a second
              finer-grained microarchitectural timing channel, related to the
              banking structure of the GPU’s Shared Memory. By considering the
              timing channel caused by Shared Memory bank conflicts, we have
              developed a differential timing attack that can compromise
              table-based cryptographic algorithms. We implement our timing
              attack on an Nvidia Kepler K40 GPU and successfully recover the
              complete 128-bit encryption key of an Advanced Encryption Standard
              (AES) GPU implementation using 900,000 timing samples. We also
              evaluate the scalability of our attack method by attacking an
              implementation of the AES encryption algorithm that fully occupies
              the compute resources of the GPU. We extend our timing analysis
              onto other Nvidia architectures: Maxwell, Pascal, Volta, and Turing
              GPUs. We also discuss countermeasures and experiment with a novel
              multi-key implementation, evaluating its resistance to our
              side-channel timing attack and its associated performance overhead.
              },
  journal = {ACM Trans. Archit. Code Optim.},
  month = nov,
  articleno = {42},
  numpages = {24},
  keywords = {microarchitectural attack, Side-channel security, GPU security},
}


@inproceedings{jiang2,
  author = {Jiang, Zhen Hang and Fei, Yunsi and Kaeli, David},
  booktitle = {2016 IEEE International Symposium on High Performance Computer
               Architecture (HPCA)},
  title = {A complete key recovery timing attack on a GPU},
  year = {2016},
  volume = {},
  number = {},
  pages = {394-405},
  keywords = {Graphics processing units;Timing;Encryption;Kernel;Message systems
              },
  doi = {10.1109/HPCA.2016.7446081},
}

@inproceedings{jiang3,
  author = {Jiang, Zhen Hang and Fei, Yunsi and Kaeli, David},
  title = {A Novel Side-Channel Timing Attack on GPUs},
  year = {2017},
  isbn = {9781450349727},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3060403.3060462},
  doi = {10.1145/3060403.3060462},
  abstract = {To avoid information leakage during program execution, modern
              software implementations of cryptographic algorithms target
              constant timing complexity, i.e., the number of instructions
              executed does not vary with different inputs. However, many times
              the underlying microarchitecture behaves differently when
              processing varying data inputs, which covertly leaks confidential
              information through the timing channel. In this paper, we exploit a
              novel fine-grained microarchitectural timing channel, stalls that
              occur due to bank conflicts in a GPU's shared memory. Using this
              attack surface, we develop a differential timing attack that can
              compromise table-based cryptographic algorithms. We implement our
              timing attack on an Nvidia Kepler K40 GPU, and successfully recover
              the complete 128-bit AES encryption key using 10 million samples.
              We also evaluate the scalability of our attack method by attacking
              a 8192-thread implementation of the AES encryption algorithm,
              recovering some key bytes using 1 million samples.},
  booktitle = {Proceedings of the Great Lakes Symposium on VLSI 2017},
  pages = {167–172},
  numpages = {6},
  keywords = {gpu security, hardware security, side-channel security, timing
              attack},
  location = {Banff, Alberta, Canada},
  series = {GLSVLSI '17},
}


@inproceedings{wang2024gpuzip,
  author = { Wang, Yingchen and Paccagnella, Riccardo and Gang, Zhao and Vasquez
            , Willy R. and Kohlbrenner, David and Shacham, Hovav and Fletcher,
            Christopher W. },
  booktitle = { 2024 IEEE Symposium on Security and Privacy (SP) },
  title = {{ GPU.zip: On the Side-Channel Implications of Hardware-Based
           Graphical Data Compression }},
  year = {2024},
  volume = {},
  ISSN = {},
  pages = {3716-3734},
  abstract = { Compression is a widely-deployed optimization that reduces data
              movement throughout modern computing stacks. Unfortunately, it is
              also a well-known source of side-channel leakage capable of leaking
              (potentially) fine-grained functions of the underlying data. There
              has, however, been a saving grace. Compression is typically
              software visible. Thus, software can "opt out" of harm’s way by
              disabling compression when sensitive data is involved, and tailor
              mitigations to known, public compression algorithms.This paper
              challenges the above conventional wisdom by demonstrating the
              existence of, and exploiting, software-transparent uses of
              compression. Specifically, we find that integrated GPUs from Intel
              and AMD vendors compress graphical data in vendor-specific and
              undocumented ways—even when software does not specifically request
              compression. Compression induces data-dependent DRAM traffic and
              cache utilization, which can be measured through side-channel
              analysis. We show the efficacy of this side channel by performing
              cross-origin SVG filter pixel stealing attacks through the browser.
              },
  keywords = {Privacy;Prevention and mitigation;Software algorithms;Random
              access memory;Side-channel attacks;Market research;Software},
  doi = {10.1109/SP54263.2024.00084},
  url = {https://doi.ieeecomputersociety.org/10.1109/SP54263.2024.00084},
  publisher = {IEEE Computer Society},
  address = {Los Alamitos, CA, USA},
  month = May,
}

@inproceedings{ahn2021trident,
  author = {Ahn, Jaeguk and Jin, Cheolgyu and Kim, Jiho and Rhu, Minsoo and Fei,
            Yunsi and Kaeli, David and Kim, John},
  booktitle = {2021 IEEE International Symposium on High-Performance Computer
               Architecture (HPCA)},
  title = {Trident: A Hybrid Correlation-Collision GPU Cache Timing Attack for
           AES Key Recovery},
  year = {2021},
  volume = {},
  number = {},
  pages = {332-344},
  keywords = {Degradation;Correlation;Microarchitecture;Graphics processing
              units;Side-channel attacks;Parallel
              processing;Throughput;GPU;AES;side-channel attack;sectored-cache},
  doi = {10.1109/HPCA51647.2021.00036},
}

@inproceedings{nag2018rendered,
  title = {Rendered insecure: Gpu side channel attacks are practical},
  author = {Naghibijouybari, Hoda and Neupane, Ajaya and Qian, Zhiyun and
            Abu-Ghazaleh, Nael},
  booktitle = {Proceedings of the 2018 ACM SIGSAC conference on computer and
               communications security},
  pages = {2139--2153},
  year = {2018},
}

@inproceedings{nag2017constructing,
  title = {Constructing and characterizing covert channels on gpgpus},
  author = {Naghibijouybari, Hoda and Khasawneh, Khaled N and Abu-Ghazaleh, Nael
            },
  booktitle = {Proceedings of the 50th Annual IEEE/ACM International Symposium
               on Microarchitecture},
  pages = {354--366},
  year = {2017},
}

@misc{mig,
  title = {NVIDIA Multi-Instance GPU (MIG) User Guide},
  url = {https://docs.nvidia.com/datacenter/tesla/mig-user-guide/},
  year = {2020},
}

@misc{amdmes,
  title = {AMD Micro Engine Scheduler},
  url = {https://gpuopen.com/download/documentation/micro_engine_scheduler.pdf},
  year = {2024},
}

@book{nvrv,
  title = {NVIDIA RISC-V Story},
  url = {
         https://riscv.org/wp-content/uploads/2024/12/Tue1100_Nvidia_RISCV_Story_V2.pdf
         },
  year = {2024},
}

@inproceedings{dmaatk,
  author = {Alex, Markuze and Vargaftik, Shay and Kupfer, Gil and Pismeny, Boris
            and Amit, Nadav and Morrison, Adam and Tsafrir, Dan},
  title = {Characterizing, exploiting, and detecting DMA code injection
           vulnerabilities in the presence of an IOMMU},
  year = {2021},
  isbn = {9781450383349},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3447786.3456249},
  doi = {10.1145/3447786.3456249},
  abstract = {Direct memory access (DMA) renders a system vulnerable to DMA
              attacks, in which I/O devices access memory regions not intended
              for their use. Hardware input-output memory management units
              (IOMMU) can be used to provide protection. However, an IOMMU cannot
              prevent all DMA attacks because it only restricts DMA at page-level
              granularity, leading to sub-page vulnerabilities.Current DMA
              attacks rely on simple situations in which write access to a kernel
              pointer is obtained due to sub-page vulnerabilities and all other
              attack ingredients are available and reside on the same page. We
              show that DMA vulnerabilities are a deep-rooted issue and it is
              often the kernel design that enables complex and multistage DMA
              attacks. This work presents a structured top-down approach to
              characterize, exploit, and detect them.To this end, we first
              categorize sub-page vulnerabilities into four types, providing
              insight into the structure of DMA vulnerabilities. We then identify
              a set of three vulnerability attributes that are sufficient to
              execute code injection attacks.We built analysis tools that detect
              these sub-page vulnerabilities and analyze the Linux kernel. We
              found that 72\% of the device drivers expose callback pointers,
              which may be overwritten by a device to hijack the kernel control
              flow.Aided by our tools' output, we demonstrate novel code
              injection attacks on the Linux kernel; we refer to these as
              compound attacks. All previously reported attacks are single-step,
              with the vulnerability attributes present in a single page. In
              compound attacks, the vulnerability attributes are initially
              incomplete. However, we demonstrate that they can be obtained by
              carefully exploiting standard OS behavior.},
  booktitle = {Proceedings of the Sixteenth European Conference on Computer
               Systems},
  pages = {395–409},
  numpages = {15},
  location = {Online Event, United Kingdom},
  series = {EuroSys '21},
}

@misc{linuxfw,
  title = {Linux GPU MCU Firmware},
  url = {
         https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/tree/arm/mali/arch10.8
         },
  year = {2024},
}

@misc{aospfw,
  title = {Android Open Source Project GPU Firmware},
  url = {
         https://android.googlesource.com/device/google/coral/refs/heads/master/firmware/g610/
         },
  year = {2024},
}

@misc{mtkfw,
  title = {MediaTek GPU MCU Firmware on GitHub},
  url = {
         https://github.com/hailongfan-mtk/linux_fw_sof/tree/main/arm/mali/arch10.8
         },
  year = {2024},
}

@misc{rockchipfw,
  title = {Rockchip GPU MCU Firmware on GitHub},
  url = {https://github.com/JeffyCN/mirrors/tree/libmali/firmware/g610},
  year = {2024},
}

@misc{malidrv,
  title = {Mali GPU Driver},
  url = {https://developer.arm.com/downloads/-/mali-drivers/valhall-kernel},
  year = {2024},
}

@misc{cve,
  title = {malicve},
  url = {
         https://developer.arm.com/Arm%20Security%20Center/Mali%20GPU%20Driver%20Vulnerabilities
         },
  year = {2024},
}

@misc{oclaes,
  title = {opencl-aes},
  url = {https://github.com/zhoukaidev/opencl-aes.git},
  year = {2018},
}

@inproceedings{torch,
  title = {Automatic differentiation in PyTorch},
  author = {Paszke, Adam and Gross, Sam and Chintala, Soumith and Chanan,
            Gregory and Yang, Edward and DeVito, Zachary and Lin, Zeming and
            Desmaison, Alban and Antiga, Luca and Lerer, Adam},
  booktitle = {NIPS-W},
  year = {2017},
}

@misc{tensorflow,
  title = { {TensorFlow}: Large-Scale Machine Learning on Heterogeneous Systems},
  url = {https://www.tensorflow.org/},
  note = {Software available from tensorflow.org},
  author = { Mart\'{i}n~Abadi and Ashish~Agarwal and Paul~Barham and Eugene~
            Brevdo and Zhifeng~Chen and Craig~Citro and Greg~S.~Corrado and Andy~
            Davis and Jeffrey~Dean and Matthieu~Devin and Sanjay~Ghemawat and Ian
            ~Goodfellow and Andrew~Harp and Geoffrey~Irving and Michael~Isard and
            Yangqing Jia and Rafal~Jozefowicz and Lukasz~Kaiser and Manjunath~
            Kudlur and Josh~Levenberg and Dandelion~Man\'{e} and Rajat~Monga and
            Sherry~Moore and Derek~Murray and Chris~Olah and Mike~Schuster and
            Jonathon~Shlens and Benoit~Steiner and Ilya~Sutskever and Kunal~
            Talwar and Paul~Tucker and Vincent~Vanhoucke and Vijay~Vasudevan and
            Fernanda~Vi\'{e}gas and Oriol~Vinyals and Pete~Warden and Martin~
            Wattenberg and Martin~Wicke and Yuan~Yu and Xiaoqiang~Zheng},
  year = {2015},
}

@article{opencv,
  author = {Bradski, G.},
  citeulike-article-id = {2236121},
  journal = {Dr. Dobb's Journal of Software Tools},
  keywords = {bibtex-import},
  posted-at = {2008-01-15 19:21:54},
  priority = {4},
  title = {{The OpenCV Library}},
  year = {2000},
}

@inproceedings{openacc,
  author = {Herdman, J. A. and Gaudin, W. P. and Perks, O. and Beckingsale, D.
            A. and Mallinson, A. C. and Jarvis, S. A.},
  booktitle = {2014 First Workshop on Accelerator Programming using Directives},
  title = {Achieving Portability and Performance through OpenACC},
  year = {2014},
  volume = {},
  number = {},
  pages = {19-26},
  keywords = {Kernel;Graphics processing units;Computer
              architecture;Programming;Acceleration;Hardware;Microprocessors},
  doi = {10.1109/WACCPD.2014.10},
}


@inproceedings{paddle,
  author = {Bi, Ran and Xu, Tongtong and Xu, Mingxue and Chen, Enhong},
  booktitle = {2022 IEEE 24th Int Conf on High Performance Computing &
               Communications; 8th Int Conf on Data Science & Systems; 20th Int
               Conf on Smart City; 8th Int Conf on Dependability in Sensor, Cloud
               & Big Data Systems & Application (HPCC/DSS/SmartCity/DependSys)},
  title = {PaddlePaddle: A Production-Oriented Deep Learning Platform
           Facilitating the Competency of Enterprises},
  year = {2022},
  volume = {},
  number = {},
  pages = {92-99},
  keywords = {Deep learning;Industries;Visualization;Software
              architecture;Software algorithms;User experience;Mathematics;deep
              learning platform;PaddlePaddle;employ-ees development;technology
              growth},
  doi = {10.1109/HPCC-DSS-SmartCity-DependSys57074.2022.00046},
}


@misc{compsan,
  author = {NVIDIA},
  title = {Compute Sanitizer},
  url = {https://developer.nvidia.com/compute-sanitizer},
  year = {2025},
}

@inproceedings{llvm,
  Author = {Chris Lattner and Vikram Adve},
  Title = {{LLVM}: A Compilation Framework for Lifelong Program Analysis and
           Transformation},
  Booktitle = CGO,
  Address = {San Jose, CA, USA},
  Month = {Mar},
  Year = {2004},
  pages = {75–88},
}

@article{sharedmem,
  author = {Mark Harris},
  title = {Using Shared Memory in CUDA C/C++ | NVIDIA Technical Blog},
  year = {2025},
  url = {https://developer.nvidia.com/blog/using-shared-memory-cuda-cc/},
}

@article{opennv,
  author = {NVIDIA},
  title = {NVIDIA/open-gpu-kernel-modules: NVIDIA Linux open GPU kernel module
           source},
  year = {2025},
  url = {https://github.com/NVIDIA/open-gpu-kernel-modules},
}

@inproceedings{asan,
  author = {Serebryany, Konstantin and Bruening, Derek and Potapenko, Alexander
            and Vyukov, Dmitry},
  title = {AddressSanitizer: a fast address sanity checker},
  year = {2012},
  publisher = {USENIX Association},
  address = {USA},
  abstract = {Memory access bugs, including buffer overflows and uses of freed
              heap memory, remain a serious problem for programming languages
              like C and C++. Many memory error detectors exist, but most of them
              are either slow or detect a limited set of bugs, or both.This paper
              presents AddressSanitizer, a new memory error detector. Our tool
              finds out-of-bounds accesses to heap, stack, and global objects, as
              well as use-after-free bugs. It employs a specialized memory
              allocator and code instrumentation that is simple enough to be
              implemented in any compiler, binary translation system, or even in
              hardware.AddressSanitizer achieves efficiency without sacrificing
              comprehensiveness. Its average slowdown is just 73\% yet it
              accurately detects bugs at the point of occurrence. It has found
              over 300 previously unknown bugs in the Chromium browser and many
              bugs in other software.},
  booktitle = {Proceedings of the 2012 USENIX Conference on Annual Technical
               Conference},
  pages = {28},
  numpages = {1},
  location = {Boston, MA},
  series = {USENIX ATC'12},
}

@article{lam,
  author = {Intel},
  title = {Enable Intel LAM in Linux},
  year = {2025},
  url = {
         https://lpc.events/event/11/contributions/1010/attachments/875/1679/LAM-LPC-2021.pdf
         },
}

@inproceedings{lowfat,
  author = {Kwon, Albert and Dhawan, Udit and Smith, Jonathan M. and Knight,
            Thomas F. and DeHon, Andre},
  title = {Low-fat pointers: compact encoding and efficient gate-level
           implementation of fat pointers for spatial safety and capability-based
           security},
  year = {2013},
  isbn = {9781450324779},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2508859.2516713},
  doi = {10.1145/2508859.2516713},
  abstract = {Referencing outside the bounds of an array or buffer is a common
              source of bugs and security vulnerabilities in today's software. We
              can enforce spatial safety and eliminate these violations by
              inseparably associating bounds with every pointer (fat pointer) and
              checking these bounds on every memory access. By further adding
              hardware-managed tags to the pointer, we make them unforgeable.
              This, in turn, allows the pointers to be used as capabilities to
              facilitate fine-grained access control and fast security domain
              crossing. Dedicated checking hardware runs in parallel with the
              processor's normal datapath so that the checks do not slow down
              processor operation (0\% runtime overhead). To achieve the safety
              of fat pointers without increasing program state, we compactly
              encode approximate base and bound pointers along with exact address
              pointers for a 46b address space into one 64-bit word with a
              worst-case memory overhead of 3\%. We develop gate-level
              implementations of the logic for updating and validating these
              compact fat pointers and show that the hardware requirements are
              low and the critical paths for common operations are smaller than
              processor ALU operations. Specifically, we show that the
              fat-pointer check and update operations can run in a 4 ns clock
              cycle on a Virtex 6 (40nm) implementation while only using 1100
              6-LUTs or about the area of a double-precision, floating-point
              adder.},
  booktitle = {Proceedings of the 2013 ACM SIGSAC Conference on Computer \&
               Communications Security},
  pages = {721–732},
  numpages = {12},
  keywords = {spatial confinement, security, processor, memory safety, fat
              pointer, capabilities},
  location = {Berlin, Germany},
  series = {CCS '13},
}

@article{blackwell,
  author = {NVIDIA},
  title = {The Engine Behind AI Factories | NVIDIA Blackwell Architecture},
  year = {2025},
  url = {
         https://www.nvidia.com/en-us/data-center/technologies/blackwell-architecture/
         },
}

@inproceedings{imt,
  author = {Sullivan, Michael B. and Ziad, Mohamed Tarek Ibn and Jaleel, Aamer
            and Keckler, Stephen W.},
  title = {Implicit Memory Tagging: No-Overhead Memory Safety Using Alias-Free
           Tagged ECC},
  year = {2023},
  isbn = {9798400700958},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3579371.3589102},
  doi = {10.1145/3579371.3589102},
  abstract = {Memory safety is a major security concern for unsafe programming
              languages, including C/C++ and CUDA/OpenACC. Hardware-accelerated
              memory tagging is an effective mechanism for detecting memory
              safety violations; however, its adoption is challenged by
              significant meta-data storage and memory traffic overheads. This
              paper proposes Implicit Memory Tagging (IMT), a novel approach that
              provides no-overhead hardware-accelerated memory tagging by
              leveraging the system error correcting code (ECC) to check for the
              equivalence of a memory tag in addition to its regular duties of
              detecting and correcting data errors. Implicit Memory Tagging
              relies on a new class of ECC codes called Alias-Free Tagged ECC
              (AFT-ECC) that can unambiguously identify tag mismatches in the
              absence of data errors, while maintaining the efficacy of ECC when
              data errors are present. When applied to GPUs, IMT addresses the
              increasing importance of GPU memory safety and the costs of adding
              meta-data to GPU memory. Ultimately, IMT detects memory safety
              violations without meta-data storage or memory access overheads. In
              practice, IMT can provide larger tag sizes than existing industry
              memory tagging implementations, enhancing security.},
  booktitle = {Proceedings of the 50th Annual International Symposium on
               Computer Architecture},
  articleno = {67},
  numpages = {13},
  keywords = {memory tagging, memory security, error correcting codes},
  location = {Orlando, FL, USA},
  series = {ISCA '23},
}

@article{bug1,
  author = {jwnhy},
  title = {[CUDA] Illegal Memory Access with `ConvTranspose2d` · Issue #144611 ·
           pytorch/pytorch},
  year = {2025},
  url = {https://github.com/pytorch/pytorch/issues/144611},
}

@article{bug2,
  author = {jwnhy},
  title = {[CUDA] Illegal Memory Access with `AdaptiveAvgPool2d` · Issue #145349
           · pytorch/pytorch},
  year = {2025},
  url = {https://github.com/pytorch/pytorch/issues/145349},
}

@article{bug3,
  author = {ChaitanyaRS06},
  title = {Tensor.long() produces inconsistent results for torch.inf between CPU
           and GPU · Issue #154724 · pytorch/pytorch},
  year = {2025},
  url = {https://github.com/pytorch/pytorch/issues/154724},
}

@article{bug4,
  author = {SilentTester73},
  title = {Crash in `SparseBincount` due to overflow · Issue #94118 ·
           tensorflow/tensorflow},
  year = {2025},
  url = {https://github.com/tensorflow/tensorflow/issues/94118},
}

@inproceedings{asanmin,
  author = {Yuchen Zhang and Chengbin Pang and Georgios Portokalidis and Nikos
            Triandopoulos and Jun Xu},
  title = {Debloating Address Sanitizer},
  booktitle = {31st USENIX Security Symposium (USENIX Security 22)},
  year = {2022},
  isbn = {978-1-939133-31-1},
  address = {Boston, MA},
  pages = {4345--4363},
  url = {
         https://www.usenix.org/conference/usenixsecurity22/presentation/zhang-yuchen
         },
  publisher = {USENIX Association},
  month = aug,
}

@article{rsan,
  author = {Floris Gorter and Cristiano Giuffrida},
  title = {RangeSanitizer: Detecting Memory Errors with Efficient Range Checks},
  year = {2025},
  url = {https://www.usenix.org/conference/usenixsecurity25/presentation/gorter},
}

@inproceedings{mtsan,
  author = {Xingman Chen and Yinghao Shi and Zheyu Jiang and Yuan Li and Ruoyu
            Wang and Haixin Duan and Haoyu Wang and Chao Zhang},
  title = {{MTSan}: A Feasible and Practical Memory Sanitizer for Fuzzing {COTS}
           Binaries},
  booktitle = {32nd USENIX Security Symposium (USENIX Security 23)},
  year = {2023},
  isbn = {978-1-939133-37-3},
  address = {Anaheim, CA},
  pages = {841--858},
  url = {
         https://www.usenix.org/conference/usenixsecurity23/presentation/chen-xingman
         },
  publisher = {USENIX Association},
  month = aug,
}

@misc{pacsan,
  title = {PACSan: Enforcing Memory Safety Based on ARM PA},
  author = {Yuan Li and Wende Tan and Zhizheng Lv and Songtao Yang and Mathias
            Payer and Ying Liu and Chao Zhang},
  year = {2022},
  eprint = {2202.03950},
  archivePrefix = {arXiv},
  primaryClass = {cs.CR},
  url = {https://arxiv.org/abs/2202.03950},
}

@inproceedings{floatzone,
  author = {Floris Gorter and Enrico Barberis and Raphael Isemann and Erik van
            der Kouwe and Cristiano Giuffrida and Herbert Bos},
  title = {{FloatZone}: Accelerating Memory Error Detection using the Floating
           Point Unit},
  booktitle = {32nd USENIX Security Symposium (USENIX Security 23)},
  year = {2023},
  isbn = {978-1-939133-37-3},
  address = {Anaheim, CA},
  pages = {805--822},
  url = {https://www.usenix.org/conference/usenixsecurity23/presentation/gorter},
  publisher = {USENIX Association},
  month = aug,
}

@inproceedings{dangzero,
  author = {Floris Gorter and Enrico Barberis and Raphael Isemann and Erik van
            der Kouwe and Cristiano Giuffrida and Herbert Bos},
  title = {{FloatZone}: Accelerating Memory Error Detection using the Floating
           Point Unit},
  booktitle = {32nd USENIX Security Symposium (USENIX Security 23)},
  year = {2023},
  isbn = {978-1-939133-37-3},
  address = {Anaheim, CA},
  pages = {805--822},
  url = {https://www.usenix.org/conference/usenixsecurity23/presentation/gorter},
  publisher = {USENIX Association},
  month = aug,
}

@inproceedings{klee,
  author = {Cristian Cadar and Daniel Dunbar and Dawson Engler},
  title = {{KLEE}: Unassisted and Automatic Generation of {High-Coverage} Tests
           for Complex Systems Programs},
  booktitle = {8th USENIX Symposium on Operating Systems Design and
               Implementation (OSDI 08)},
  year = {2008},
  address = {San Diego, CA},
  url = {
         https://www.usenix.org/conference/osdi-08/klee-unassisted-and-automatic-generation-high-coverage-tests-complex-systems
         },
  publisher = {USENIX Association},
  month = dec,
}

@inproceedings{svf,
  author = {Cristian Cadar and Daniel Dunbar and Dawson Engler},
  title = {{KLEE}: Unassisted and Automatic Generation of {High-Coverage} Tests
           for Complex Systems Programs},
  booktitle = {8th USENIX Symposium on Operating Systems Design and
               Implementation (OSDI 08)},
  year = {2008},
  address = {San Diego, CA},
  url = {
         https://www.usenix.org/conference/osdi-08/klee-unassisted-and-automatic-generation-high-coverage-tests-complex-systems
         },
  publisher = {USENIX Association},
  month = dec,
}

@inproceedings{ucklee,
  author = {David A. Ramos and Dawson Engler},
  title = {{Under-Constrained} Symbolic Execution: Correctness Checking for Real
           Code},
  booktitle = {24th USENIX Security Symposium (USENIX Security 15)},
  year = {2015},
  isbn = {978-1-939133-11-3},
  address = {Washington, D.C.},
  pages = {49--64},
  url = {
         https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/ramos
         },
  publisher = {USENIX Association},
  month = aug,
}

@inproceedings{drchecker,
  author = {Aravind Machiry and Chad Spensky and Jake Corina and Nick Stephens
            and Christopher Kruegel and Giovanni Vigna},
  title = {{DR}. {CHECKER}: A Soundy Analysis for Linux Kernel Drivers},
  booktitle = {26th USENIX Security Symposium (USENIX Security 17)},
  year = {2017},
  isbn = {978-1-931971-40-9},
  address = {Vancouver, BC},
  pages = {1007--1024},
  url = {
         https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/machiry
         },
  publisher = {USENIX Association},
  month = aug,
}

@inproceedings{uafx,
  series = {NDSS 2025},
  title = {Statically Discover Complex Cross-Entry Use-After-Free
           Vulnerabilities in the Linux Kernel},
  url = {http://dx.doi.org/10.14722/ndss.2025.240559},
  DOI = {10.14722/ndss.2025.240559},
  booktitle = {Proceedings 2025 Network and Distributed System Security
               Symposium},
  publisher = {Internet Society},
  author = {Zhang, Hang and Kim, Jangha and Yuan, Chuhong and Qian, Zhiyun and
            Kim, Taesoo},
  year = {2025},
  collection = {NDSS 2025},
}

@inproceedings{mangodfa,
  author = {Wil Gibbs and Arvind S Raj and Jayakrishna Menon Vadayath and Hui
            Jun Tay and Justin Miller and Akshay Ajayan and Zion Leonahenahe
            Basque and Audrey Dutcher and Fangzhou Dong and Xavier Maso and
            Giovanni Vigna and Christopher Kruegel and Adam Doup{\'e} and Yan
            Shoshitaishvili and Ruoyu Wang},
  title = {Operation Mango: Scalable Discovery of {Taint-Style} Vulnerabilities
           in Binary Firmware Services},
  booktitle = {33rd USENIX Security Symposium (USENIX Security 24)},
  year = {2024},
  isbn = {978-1-939133-44-1},
  address = {Philadelphia, PA},
  pages = {7123--7139},
  url = {https://www.usenix.org/conference/usenixsecurity24/presentation/gibbs},
  publisher = {USENIX Association},
  month = aug,
}

@inproceedings{cpachecker,
  author = {Beyer, Dirk and Keremoglu, M. Erkan},
  title = {CPACHECKER: a tool for configurable software verification},
  year = {2011},
  isbn = {9783642221095},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  abstract = {Configurable software verification is a recent concept for
              expressing different program analysis and model checking approaches
              in one single formalism. This paper presents CPAchecker, a tool and
              framework that aims at easy integration of new verification
              components. Every abstract domain, together with the corresponding
              operations, implements the interface of configurable program
              analysis (CPA). The main algorithm is configurable to perform a
              reachability analysis on arbitrary combinations of existing CPAs.
              In software verification, it takes a considerable amount of effort
              to convert a verification idea into actual experimental results --
              we aim at accelerating this process. We hope that researchers find
              it convenient and productive to implement new verification ideas
              and algorithms using this flexible and easy-to-extend platform, and
              that it advances the field by making it easier to perform practical
              experiments. The tool is implemented in Java and runs as
              command-line tool or as Eclipse plug-in. CPAchecker implements CPAs
              for several abstract domains. We evaluate the efficiency of the
              current version of our tool on software-verification benchmarks
              from the literature, and compare it with other state-of-the-art
              model checkers. CPAchecker is an open-source toolkit and publicly
              available.},
  booktitle = {Proceedings of the 23rd International Conference on Computer
               Aided Verification},
  pages = {184–190},
  numpages = {7},
  location = {Snowbird, UT},
  series = {CAV'11},
}

@inproceedings{suture,
  author = {Zhang, Hang and Chen, Weiteng and Hao, Yu and Li, Guoren and Zhai,
            Yizhuo and Zou, Xiaochen and Qian, Zhiyun},
  title = {Statically Discovering High-Order Taint Style Vulnerabilities in OS
           Kernels},
  year = {2021},
  isbn = {9781450384544},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3460120.3484798},
  doi = {10.1145/3460120.3484798},
  abstract = {Static analysis is known to yield numerous false alarms when used
              in bug finding, especially for complex vulnerabilities in large
              code bases like the Linux kernel. One important class of such
              complex vulnerabilities is what we call "high-order taint style
              vulnerability", where the taint flow from the user input to the
              vulnerable site crosses the boundary of a single entry function
              invocation (i.e., syscall). Due to the large scope and high
              precision requirement, few have attempted to solve the problem. In
              this paper, we present SUTURE, a highly precise and scalable static
              analysis tool capable of discovering high-order vulnerabilities in
              OS kernels. SUTURE employs a novel summary-based high-order taint
              flow construction approach to efficiently enumerate the cross-entry
              taint flows, while incorporating multiple innovative enhancements
              on analysis precision that are unseen in existing tools, resulting
              in a highly precise inter-procedural flow-, context-, field-,
              index-, and opportunistically path-sensitive static taint analysis.
              We apply SUTURE to discover high-order taint vulnerabilities in
              multiple Android kernels from mainstream vendors (e.g., Google,
              Samsung, Huawei), the results show that SUTURE can both confirm
              known high-order vulnerabilities and uncover new ones. So far,
              SUTURE generates 79 true positive warning groups, of which 19 have
              been confirmed by the vendors, including a high severity
              vulnerability rated by Google. SUTURE also achieves a reasonable
              false positive rate (51.23\%) perceived by users of our tool.},
  booktitle = {Proceedings of the 2021 ACM SIGSAC Conference on Computer and
               Communications Security},
  pages = {811–824},
  numpages = {14},
  keywords = {OS kernels, static program analysis, vulnerability discovery},
  location = {Virtual Event, Republic of Korea},
  series = {CCS '21},
}

@misc{cbmc,
  title = {CBMC: The C Bounded Model Checker},
  author = {Daniel Kroening and Peter Schrammel and Michael Tautschnig},
  year = {2023},
  eprint = {2302.02384},
  archivePrefix = {arXiv},
  primaryClass = {cs.SE},
  url = {https://arxiv.org/abs/2302.02384},
}

@inproceedings{seahorn,
  author = {Gurfinkel, Arie and Kahsai, Temesghen and Navas, Jorge A.},
  title = {SeaHorn: A Framework for Verifying C Programs Competition
           Contribution},
  year = {2015},
  isbn = {9783662466803},
  publisher = {Springer-Verlag},
  address = {Berlin, Heidelberg},
  url = {https://doi.org/10.1007/978-3-662-46681-0_41},
  doi = {10.1007/978-3-662-46681-0_41},
  abstract = {seahorn is a framework and tool for verification of safety
              properties in C programs. The distinguishing feature of seahorn is
              its modular design that separates how program semantics is
              represented from the verification engine. This paper describes its
              verification approach as well as the instructions on how to install
              and use it.},
  booktitle = {Proceedings of the 21st International Conference on Tools and
               Algorithms for the Construction and Analysis of Systems - Volume
               9035},
  pages = {447–450},
  numpages = {4},
}

@inproceedings{10.1145/2384616.2384625,
  author = {Betts, Adam and Chong, Nathan and Donaldson, Alastair and Qadeer,
            Shaz and Thomson, Paul},
  title = {GPUVerify: a verifier for GPU kernels},
  year = {2012},
  isbn = {9781450315616},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2384616.2384625},
  doi = {10.1145/2384616.2384625},
  abstract = {We present a technique for verifying race- and divergence-freedom
              of GPU kernels that are written in mainstream kernel programming
              languages such as OpenCL and CUDA. Our approach is founded on a
              novel formal operational semantics for GPU programming termed
              synchronous, delayed visibility (SDV) semantics. The SDV semantics
              provides a precise definition of barrier divergence in GPU kernels
              and allows kernel verification to be reduced to analysis of a
              sequential program, thereby completely avoiding the need to reason
              about thread interleavings, and allowing existing modular
              techniques for program verification to be leveraged. We describe an
              efficient encoding for data race detection and propose a method for
              automatically inferring loop invariants required for verification.
              We have implemented these techniques as a practical verification
              tool, GPUVerify, which can be applied directly to OpenCL and CUDA
              source code. We evaluate GPUVerify with respect to a set of 163
              kernels drawn from public and commercial sources. Our evaluation
              demonstrates that GPUVerify is capable of efficient, automatic
              verification of a large number of real-world kernels.},
  booktitle = {Proceedings of the ACM International Conference on Object
               Oriented Programming Systems Languages and Applications},
  pages = {113–132},
  numpages = {20},
  keywords = {GPUs, barrier synchronization, concurrency, data races,
              verification},
  location = {Tucson, Arizona, USA},
  series = {OOPSLA '12},
}

@article{gpuverify,
  author = {Betts, Adam and Chong, Nathan and Donaldson, Alastair and Qadeer,
            Shaz and Thomson, Paul},
  title = {GPUVerify: a verifier for GPU kernels},
  year = {2012},
  issue_date = {October 2012},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {47},
  number = {10},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/2398857.2384625},
  doi = {10.1145/2398857.2384625},
  abstract = {We present a technique for verifying race- and divergence-freedom
              of GPU kernels that are written in mainstream kernel programming
              languages such as OpenCL and CUDA. Our approach is founded on a
              novel formal operational semantics for GPU programming termed
              synchronous, delayed visibility (SDV) semantics. The SDV semantics
              provides a precise definition of barrier divergence in GPU kernels
              and allows kernel verification to be reduced to analysis of a
              sequential program, thereby completely avoiding the need to reason
              about thread interleavings, and allowing existing modular
              techniques for program verification to be leveraged. We describe an
              efficient encoding for data race detection and propose a method for
              automatically inferring loop invariants required for verification.
              We have implemented these techniques as a practical verification
              tool, GPUVerify, which can be applied directly to OpenCL and CUDA
              source code. We evaluate GPUVerify with respect to a set of 163
              kernels drawn from public and commercial sources. Our evaluation
              demonstrates that GPUVerify is capable of efficient, automatic
              verification of a large number of real-world kernels.},
  journal = {SIGPLAN Not.},
  month = oct,
  pages = {113–132},
  numpages = {20},
  keywords = {GPUs, barrier synchronization, concurrency, data races,
              verification},
}


@misc{gpurepair,
  title = {GPURepair: Automated Repair of GPU Kernels},
  author = {Saurabh Joshi and Gautam Muduganti},
  year = {2020},
  eprint = {2011.08373},
  archivePrefix = {arXiv},
  primaryClass = {cs.DC},
  url = {https://arxiv.org/abs/2011.08373},
}

@inproceedings{rust,
  title = {The rust language},
  author = {Matsakis, Nicholas D and Klock II, Felix S},
  booktitle = {ACM SIGAda Ada Letters},
  volume = {34},
  number = {3},
  pages = {103--104},
  year = {2014},
  organization = {ACM},
}

@article{rustcuda,
  author = {GitHub},
  title = {Rust-GPU/Rust-CUDA: Ecosystem of libraries and tools for writing and
           executing fast GPU code fully in Rust.},
  year = {2025},
  url = {https://github.com/Rust-GPU/Rust-CUDA},
}

@misc{cudnn,
  title = {cuDNN: Efficient Primitives for Deep Learning},
  author = {Sharan Chetlur and Cliff Woolley and Philippe Vandermersch and
            Jonathan Cohen and John Tran and Bryan Catanzaro and Evan Shelhamer},
  year = {2014},
  eprint = {1410.0759},
  archivePrefix = {arXiv},
  primaryClass = {cs.NE},
  url = {https://arxiv.org/abs/1410.0759},
}

@article{kernelmalloc,
  author = {NVIDIA},
  title = {kernel malloc() efficiency really bad - CUDA / CUDA Programming and
           Performance - NVIDIA Developer Forums},
  year = {2025},
  url = {
         https://forums.developer.nvidia.com/t/kernel-malloc-efficiency-really-bad/20575
         },
}

@article{magma,
  author = {Andrzej Chrzeszczyk and Jacob Anders},
  title = {Matrix computations on the GPU CUBLAS, CUSOLVER and MAGMA by example},
  year = {2025},
  url = {https://d29g4g2dyqv443.cloudfront.net/sites/default/files/akamai/cuda/files/Misc/mygpu.pdf},
}

@misc{arrayfire,
abstract = {ArrayFire is a high performance software library for parallel computing with an easy-to-use API. Its array based function set makes parallel programming simple. ArrayFire's multiple backends (CUDA, OpenCL and native CPU) make it platform independent and highly portable. A few lines of code in ArrayFire can replace dozens of lines of parallel computing code, saving you valuable time and lowering development costs.},
address = {Atlanta},
author = {Yalamanchili, Pavan and Arshad, Umar and Mohammed, Zakiuddin and Garigipati, Pradeep and Entschev, Peter and Kloppenborg, Brian and Malcolm, James and Melonakos, John},
publisher = {AccelerEyes},
title = {{ArrayFire - A high performance software library for parallel computing with an easy-to-use API}},
url = {https://github.com/arrayfire/arrayfire},
year = {2015}
}

@article{hip,
	author	={AMD},
	title	={HIP documentation — HIP 6.4.43484 Documentation},
	year	={2025},
	url	={https://rocm.docs.amd.com/projects/HIP/en/latest/}
	}

@article{nsight,
	author	={NVIDIA},
	title	={NVIDIA Nsight Systems | NVIDIA},
	year	={2025},
	url	={https://developer.nvidia.cn/nsight-systems}
	}

@misc{polybenchgpu,
      title={Benchmarking OpenCL, OpenACC, OpenMP, and CUDA: programming productivity, performance, and energy consumption}, 
      author={Suejb Memeti and Lu Li and Sabri Pllana and Joanna Kolodziej and Christoph Kessler},
      year={2017},
      eprint={1704.05316},
      archivePrefix={arXiv},
      primaryClass={cs.DC},
      url={https://arxiv.org/abs/1704.05316}, 
}

@misc{llama2,
      title={Llama 2: Open Foundation and Fine-Tuned Chat Models}, 
      author={Hugo Touvron and others},
      year={2023},
      eprint={2307.09288},
      archivePrefix={arXiv},
      primaryClass={cs.CL},
      url={https://arxiv.org/abs/2307.09288}, 
}

@misc{llama3,
      title={The Llama 3 Herd of Models}, 
      author={Aaron Grattafiori and others},
      year={2024},
      eprint={2407.21783},
      archivePrefix={arXiv},
      primaryClass={cs.AI},
      url={https://arxiv.org/abs/2407.21783}, 
}

@article{b200,
	author	={NVIDIA},
	title	={DGX B200: The Foundation for Your AI Factory | NVIDIA},
	year	={2025},
	url	={https://www.nvidia.com/en-us/data-center/dgx-b200/}
	}

@article{cudaguide,
	author	={NVIDIA},
	title	={CUDA C++ Programming Guide — CUDA C++ Programming Guide},
	year	={2025},
	url	={https://docs.nvidia.com/cuda/cuda-c-programming-guide/}
	}

@INPROCEEDINGS{tango,
  author={Karki, Aajna and Palangotu Keshava, Chethan and Mysore Shivakumar, Spoorthi and Skow, Joshua and Madhukeshwar Hegde, Goutam and Jeon, Hyeran},
  booktitle={2019 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS)}, 
  title={Tango: A Deep Neural Network Benchmark Suite for Various Accelerators}, 
  year={2019},
  volume={},
  number={},
  pages={137-138},
  keywords={Benchmark testing;Graphics processing units;Convolution;Recurrent neural networks;Computer architecture;Pipelines;Deep neural network;Benchmark Suite},
  doi={10.1109/ISPASS.2019.00021}}


@INPROCEEDINGS{rodinia,
  author={Che, Shuai and Boyer, Michael and Meng, Jiayuan and Tarjan, David and Sheaffer, Jeremy W. and Lee, Sang-Ha and Skadron, Kevin},
  booktitle={2009 IEEE International Symposium on Workload Characterization (IISWC)}, 
  title={Rodinia: A benchmark suite for heterogeneous computing}, 
  year={2009},
  volume={},
  number={},
  pages={44-54},
  keywords={Kernel;Multicore processing;Parallel processing;Application software;Yarn;Benchmark testing;Central Processing Unit;Energy consumption;Microprocessors;Computer architecture},
  doi={10.1109/IISWC.2009.5306797}}


@inproceedings{bitflip1,
  author       = {Yanzuo Chen and
                  Zhibo Liu and
                  Yuanyuan Yuan and
                  Sihang Hu and
                  Tianxiang Li and
                  Shuai Wang},
  title        = {Compiled Models, Built-In Exploits: Uncovering Pervasive Bit-Flip
                  Attack Surfaces in {DNN} Executables},
  booktitle    = {32nd Annual Network and Distributed System Security Symposium, {NDSS}
                  2025, San Diego, California, USA, February 24-28, 2025},
  publisher    = {The Internet Society},
  year         = {2025},
  url          = {https://www.ndss-symposium.org/ndss-paper/compiled-models-built-in-exploits-uncovering-pervasive-bit-flip-attack-surfaces-in-dnn-executables/},
  timestamp    = {Wed, 19 Mar 2025 15:12:36 +0100},
  biburl       = {https://dblp.org/rec/conf/ndss/ChenLYHL025.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}




@article{bitflip2,
  author       = {Adnan Siraj Rakin and
                  Zhezhi He and
                  Deliang Fan},
  title        = {Bit-Flip Attack: Crushing Neural Network withProgressive Bit Search},
  journal      = {CoRR},
  volume       = {abs/1903.12269},
  year         = {2019},
  url          = {http://arxiv.org/abs/1903.12269},
  eprinttype    = {arXiv},
  eprint       = {1903.12269},
  timestamp    = {Tue, 02 Apr 2019 12:29:45 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-1903-12269.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{mistrain1,
author = {Ma, Yuzhe and Jun, Kwang-Sung and Li, Lihong and Zhu, Xiaojin},
title = {Data Poisoning Attacks in Contextual Bandits},
year = {2018},
isbn = {978-3-030-01553-4},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-030-01554-1_11},
doi = {10.1007/978-3-030-01554-1_11},
abstract = {We study offline data poisoning attacks in contextual bandits, a class of reinforcement learning problems with important applications in online recommendation and adaptive medical treatment, among others. We provide a general attack framework based on convex optimization and show that by slightly manipulating rewards in the data, an attacker can force the bandit algorithm to pull a target arm for a target contextual vector. The target arm and target contextual vector are both chosen by the attacker. That is, the attacker can hijack the behavior of a contextual bandit. We also investigate the feasibility and the side effects of such attacks, and identify future directions for defense. Experiments on both synthetic and real-world data demonstrate the efficiency of the attack algorithm.},
booktitle = {Decision and Game Theory for Security: 9th International Conference, GameSec 2018, Seattle, WA, USA, October 29–31, 2018, Proceedings},
pages = {186–204},
numpages = {19},
keywords = {Data poisoning, Contextual bandit, Adversarial attack},
location = {Seattle, WA, USA}
}

@article{mistrain2,
   title={The effects of data quality on machine learning performance on tabular data},
   volume={132},
   ISSN={0306-4379},
   url={http://dx.doi.org/10.1016/j.is.2025.102549},
   DOI={10.1016/j.is.2025.102549},
   journal={Information Systems},
   publisher={Elsevier BV},
   author={Mohammed, Sedir and Budach, Lukas and Feuerpfeil, Moritz and Ihde, Nina and Nathansen, Andrea and Noack, Nele and Patzlaff, Hendrik and Naumann, Felix and Harmouch, Hazar},
   year={2025},
   month=jul, pages={102549} }


@article{cusan,
	author	={Anonymous},
	title	={CuSan Website},
	year	={2025},
	url	={https://sites.google.com/view/safe-gpu/}
	}
